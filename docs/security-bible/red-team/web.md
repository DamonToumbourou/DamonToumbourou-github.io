---
layout: default
title: Web
parent: Red Team
grand_parent: Security Bible
nav_order: 1
---

# Web Attacks
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---
## Cross-Site Scripting 
Cross-Site Scripting is also known as a client-side injection attack, which aims at executing malicious scripts on a victim’s web browser by injecting malicious code.

### Definitions of XSS: 
Early on, two primary types of XSS were identified, Stored XSS and Reflected XSS. In 2005, Amit Klein defined a third type of XSS, which Amit coined DOM Based XSS. These 3 types of XSS are defined as follows:

* **Reflected** XSS (AKA Non-Persistent or Type I):
Reflected XSS occurs when user input is immediately returned by a web application in an error message, search result, or any other response that includes some or all of the input provided by the user as part of the request, without that data being made safe to render in the browser, and without permanently storing the user provided data. In some cases, the user provided data may never even leave the browser (see DOM Based XSS below).

* **Stored** XSS (AKA Persistent or Type II)
Stored XSS generally occurs when user input is stored on the target server, such as in a database, in a message forum, visitor log, comment field, etc. And then a victim is able to retrieve the stored data from the web application without that data being made safe to render in the browser. With the advent of HTML5, and other browser technologies, we can envision the attack payload being permanently stored in the victim’s browser, such as an HTML5 database, and never being sent to the server at all.

* **DOM Based** XSS (AKA Type-0)
As defined by Amit Klein, who published the first article about this issue [1], DOM Based XSS is a form of XSS where the entire tainted data flow from source to sink takes place in the browser, i.e., the source of the data is in the DOM, the sink is also in the DOM, and the data flow never leaves the browser. For example, the source (where malicious data is read) could be the URL of the page (e.g., document.location.href), or it could be an element of the HTML, and the sink is a sensitive method call that causes the execution of the malicious data (e.g., document.write).”


### Types of XSS: 
For years, most people thought of these (Stored, Reflected, DOM) as three different types of XSS, but in reality, they overlap. You can have both Stored and Reflected DOM Based XSS. You can also have Stored and Reflected Non-DOM Based XSS too, but that’s confusing, so to help clarify things, starting about mid 2012, the research community proposed and started using two new terms to help organize the types of XSS that can occur:

* **Server XSS**
Server XSS occurs when untrusted user supplied data is included in an HTTP response generated by the server. The source of this data could be from the request, or from a stored location. As such, you can have both Reflected Server XSS and Stored Server XSS.

In this case, the entire vulnerability is in server-side code, and the browser is simply rendering the response and executing any valid script embedded in it.

* **Client XSS**
Client XSS occurs when untrusted user supplied data is used to update the DOM with an unsafe JavaScript call. A JavaScript call is considered unsafe if it can be used to introduce valid JavaScript into the DOM. This source of this data could be from the DOM, or it could have been sent by the server (via an AJAX call, or a page load). The ultimate source of the data could have been from a request, or from a stored location on the client or the server. As such, you can have both Reflected Client XSS and Stored Client XSS.

With these new definitions, the definition of DOM Based XSS doesn’t change. DOM Based XSS is simply a subset of Client XSS, where the source of the data is somewhere in the DOM, rather than from the Server.

Given that both Server XSS and Client XSS can be Stored or Reflected, this new terminology results in a simple, clean, 2 x 2 matrix with Client & Server XSS on one axis, and Stored and Reflected XSS on the other axis as depicted in Dave Witchers’ DOM Based XSS talk 

### XSS Examples 
#### **Reflected XSS Attack on a Search query**

Assume a web app accepts a search string from users through a search parameter within a query string:
``` yaml
http://darwin.com/aform.html?search=Hacker1

```
In the event the application server uses PHP to show the user-supplied value on the results page by pulling it from the URL and then generating the resulting HTML:
``` yaml
<?php echo 'You Searched:' .$_GET["search"];?>

```
The web server directly parses the user-supplied value in the URL to HTML with no input validation or output encoding. In such instances, attackers can craft arbitrary code that is executed in the browser when the victim clicks on the URL:

``` yaml
http://darwin.com/aform.html?search=<script>alert('XSS by Product1');</script>
```
This script gives hackers access to the user’s session cookie and allows them to assume a legitimate user’s identity.

#### **Reflected XSS Attack on an Error Message**
Suppose a web page accepts an input parameter that contains the text displayed in an error message and displays it directly within its response. In that case, attackers use such vulnerabilities to orchestrate XSS attacks. 

Assuming the URL that returns the error message as:
```
http://darwin.com/error/5/Error.ashx?message=Sorry%20+some+error+message
```
The returned error page directly copies the values of the URL’s message parameter then displays it suitably within the page:

``` yaml
<p>Sorry, some error message</>
```

Without sanitization or appropriate validation, attackers can create a malicious payload to generate a pop-up screen:

``` yaml
http://darwin.com/error/5/Error.ashx?message=<script>alert("XSS by Hacker1")</script>
```

If an unsuspecting user requests this page, the browser executes the malicious script, redirecting the user to an HTML page with the following content in place of the actual content:

``` yaml
<p><scrRipt>alert("XSS by Hacker1");</script></p>

```

#### **Stored XSS example**
Suppose a website allows users to submit comments on blog posts, which are displayed to other users. Users submit comments using an HTTP request like the following:

``` yaml
POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Length: 100

postId=3&comment=This+post+was+extremely+helpful.&name=Carlos+Montoya&email=carlos%40normal-user.net
```

After this comment has been submitted, any user who visits the blog post will receive the following within the application's response:

``` yaml
<p>This post was extremely helpful.</p>
```

Assuming the application doesn't perform any other processing of the data, an attacker can submit a malicious comment like this:

``` yaml
<script>/* Bad stuff here... */</script>
```

Within the attacker's request, this comment would be URL-encoded as:
``` yaml 
comment=%3Cscript%3E%2F*%2BBad%2Bstuff%2Bhere...%2B*%2F%3C%2Fscript%3E
```

Any user who visits the blog post will now receive the following within the application's response:
``` yaml
<p><script>/* Bad stuff here... */</script></p>
```
---